<link href='http://fonts.googleapis.com/css?family=Roboto:100,300'
rel='stylesheet' type='text/css'>
<script
src="http://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<style type="text/css">
.text {
  font-family: "Roboto", sans-serif;
  font-size: 11pt;
  font-weight: 300;
  cursor: default;
}

.text:hover {
  stroke: #100873;
}

.link {
  fill: none;
  stroke: gray;
  stroke-width: 1.5px;
}

</style>

<script type="text/javascript">

// The alignment-baseline property is SVG standard, but Firefox does not support
// it yet. Thus this will work worse in Firefox.

// Global object.
var OntoVis = {};
OntoVis.width = 960;
OntoVis.height = 800;
OntoVis.marginX = 80;
OntoVis.marginY = 20;
OntoVis.nodePaddingX = 5;
OntoVis.nodePaddingY = 3;
OntoVis.duration = 500;
OntoVis.maxLevelDistance = 250;

// projection() specifies a transform of coordinates for generated links.
OntoVis._diagonal = d3.svg.diagonal().projection(
  function(d) {
    return [d.y, d.x];
  });
OntoVis._colors = d3.scale.category20();

OntoVis.SVG = function(element_name) {
  var e = document.createElementNS("http://www.w3.org/2000/svg", element_name);
  if (e.tagName == 'svg') {
    $(e).attr("xmlns:xlink", "http://www.w3.org/1999/xlink");
  }
  return e;
}

// Create and initialize the layout.
OntoVis.createLayout = function() {
  // Initialize color palette.
  for (var c = 0; c < 20; ++c) {
    console.log("color " + c + ": " + OntoVis._colors(c));
  }

  // Initialize the SVG canvas.
  var svg = OntoVis.SVG("svg");
  $("div#viz").append(svg);
  $(svg).attr("width", OntoVis.width);
  $(svg).attr("height", OntoVis.height);

  var g_links = OntoVis.SVG("g");
  $(g_links).attr("id", "links");
  $(g_links).attr("transform",
                  "translate(" + OntoVis.marginX + " " + OntoVis.marginY + ")");
  $(svg).append(g_links);
  var g_texts = OntoVis.SVG("g");
  $(g_texts).attr("id", "elements");
  $(svg).append(g_texts);

  // Initialize the tree layout.
  var visibleWidth = OntoVis.width - OntoVis.marginX * 2;
  var visibleHeight = OntoVis.height - OntoVis.marginY * 2;
  var layout = d3.layout.tree()
    .size([visibleWidth, visibleHeight])
    .children(function(d) { return d.subtypes; });
  OntoVis.layout = layout;

  // Load JSON data and initialize.
  d3.json("mmd_repo.json", function(error, root) {
      OntoVis.root = root;
      // See the later explanation of x0 and y0.
      root.x0 = 0;
      root.y0 = OntoVis.height / 2;

      function collapse(node) {
        if (node.subtypes) {
          node._subtypes = node.subtypes;
          node.subtypes.forEach(collapse);
          node.subtypes = null;
        }
      }
      // Collapse subtrees.
      root.subtypes.forEach(collapse);

      OntoVis.update(root);
  });
}

// Update the presentation when clicking events happen.
OntoVis.update = function(source) {
  // Use D3 to generate the layout.
  // This will set the x-y coordinates for nodes.
  var nodes = OntoVis.layout.nodes(OntoVis.root);
  var links = OntoVis.layout.links(nodes);

  // Adjust margin and the max distance between two levels of nodes, for
  // readability.
  var minX = 1 << 30;
  nodes.forEach(function(d) {
    if (d.x < minX) {
      minX = d.x;
    }
    if (d.y > d.depth * OntoVis.maxLevelDistance) {
      d.y = d.depth * OntoVis.maxLevelDistance;
    }
  });
  console.log("minX = " + minX);
  nodes.forEach( function(d) {
    d.x = d.x - minX;
  });

  // Select nodes and bind data.
  var elements = d3.select("div#viz > svg > g#elements").selectAll("g.g1");
  // The 2nd argument determines an ID, so that D3 can maintain correspondence
  // between data and generated visuals.
  var node = elements.data(nodes, function(d) { return d.name; });

  // For entering nodes, initially create them at the clicked node (which is
  // their parent node).
  //
  // Since the source may be relocated at the beginning of update(), we need to
  // use the saved previous location of the source node, which is specified in
  // source.x0 and source.y0.
  //
  // Translates are specified on the <g> element so that the bounding box can be
  // translated along with the text.
  var enteringNodes =
    node.enter()
      .insert("g", ":first-child")
      .attr("class", "g1")
      .attr("transform",
            function(d) {
              var x = source.y0 + OntoVis.marginX;
              var y = source.x0 + OntoVis.marginY;
              return "translate(" + x + " " + y + ")";
            });
  var g2s = enteringNodes.insert("g").attr("class", "g2");

  g2s.insert("text")
    .attr("id", function(d) { return "text_" + d.name; })
    .attr("class", "text")
    .attr("text-anchor", "middle")
    .attr("alignment-baseline", "middle")
    .text(function(d) { return d.name; })
    .on("click", OntoVis.click);

  var bbox1 = function(shape) {
    return $(shape.parentNode.parentNode).select("text.text")[0].getBBox();
  }
  var anchors =
    g2s
      .insert("a")
      .attr("style", function(d) {
        if (d.example_url) {
          return "";
        } else {
          return "display: none";
        }
      })
      .attr("class", "node_anchor")
      .attr("xlink:href", function(d) {
        if (d.example_url) {
          return OntoVis.getMiceUrl(d.example_url);
        } else {
          return "#";
        }
      })
      .attr("xlink:show", function(d) {
        if (d.example_url) {
          return "new";
        } else {
          return "none";
        }
      })
      .insert("g")
      .attr("class", "node_anchor_g")
      .attr("stroke", "#444444")
      .attr("stroke-linecap", "round")
      .attr("fill", "white")
      .attr("transform", function(d) {
         var x = bbox1(this).width / 2 + 5;
         return "translate(" + x + ", -8)";
      });
  anchors
    .insert("path")
    .attr("stroke-width", "0")
    .attr("d", "M0 0 L0 12 L12 12 L12 0 Z");
  anchors
    .insert("path")
    .attr("stroke-width", "1.5")
    .attr("d", "M2 0 L0 0 L0 12 L12 12 L12 10");
  anchors
    .insert("path")
    .attr("stroke-width", "3")
    .attr("d", "M6 0 L12 0 L12 6 M12 0 L5 7");

  // Add boxes.
  var bbox2 = function(shape) {
    return $(shape.parentNode).select("g.g2")[0].getBBox();
  }
  var px = OntoVis.nodePaddingX;
  var py = OntoVis.nodePaddingY;
  enteringNodes
    .insert("rect", ":first-child")
    .attr("id", function(d) { return "box_" + d.name; })
    .attr("fill", function(d) { return OntoVis._colors(d.depth % 10 * 2 + 1); })
    .attr("rx", "5")
    .attr("ry", "5")
    .attr("x", function(d) { return bbox2(this).x - px; })
    .attr("y", function(d) { return bbox2(this).y - py; })
    .attr("width", function(d) { return bbox2(this).width + px * 2; })
    .attr("height", function(d) { return bbox2(this).height + py * 2; });

  // enteringNodes.select("text").on("click", OntoVis.click);

  // Transit existing and entering nodes to their new locations (specified in
  // d.x and d.y).
  node
    .transition()
    .duration(OntoVis.duration)
    .attr("transform",
          function(d) {
            var x = d.y + OntoVis.marginX;
            var y = d.x + OntoVis.marginY;
            return "translate(" + x + " " + y + ")";
          });

  // For exiting nodes, transit them to the clicked node (which is their
  // parent) before removing them.
  node.exit()
    .transition()
    .duration(OntoVis.duration)
    .attr("transform",
          function(d) {
            var x = source.y + OntoVis.marginX;
            var y = source.x + OntoVis.marginY;
            console.log("exiting: ")
            console.log(this);
            return "translate(" + x + " " + y + ")";
          })
    .remove();

  // Bind links data.
  var connectors = d3.select("div#viz > svg > g#links").selectAll("path");
  // Again, the 2nd argument determines an ID for maintaining correspondence.
  var link = connectors.data(links, function(d) { return d.target.name; });

  // For entering links, initially show them as essentially 1 point near the
  // saved location of the clicked node.
  link.enter()
    .insert("path")
      .attr("class", "link")
      .attr("d",
            function(d) {
              var o = { x: source.x0, y: source.y0 };
              return OntoVis._diagonal({ source: o, target: o });
            });

  // Transit existing and entering links to their full shapes and new locations.
  link
    .transition()
    .duration(OntoVis.duration)
    .attr("d", OntoVis._diagonal);

  // For exiting links, transit them into 1 point near the clicked node before
  // removing.
  link.exit()
    .transition()
    .duration(OntoVis.duration)
    .attr("d",
          function(d) {
            var o = { x: source.x, y: source.y };
            return OntoVis._diagonal({ source: o, target: o });
          })
    .remove();

  // Save the location of each node before next update().
  nodes.forEach(function(d) { d.x0 = d.x; d.y0 = d.y; });
}

OntoVis.getMiceUrl = function(url) {
  var eurl = encodeURIComponent(url);
  return "http://ecologylab.net/mice?url=" + eurl;
}

OntoVis.click = function(d) {
  console.log(d);
  if (d.subtypes) {
    // Collapse
    d._subtypes = d.subtypes;
    d.subtypes = null;
  } else {
    // Expand
    d.subtypes = d._subtypes;
    d._subtypes = null;
  }
  OntoVis.update(d);
}

$(document).ready(OntoVis.createLayout);
</script>

<body>

<div id="viz">
</div>

</body>
