<link href='http://fonts.googleapis.com/css?family=Roboto:100,300'
rel='stylesheet' type='text/css'>
<script
src="http://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<style type="text/css">
.text {
  font-family: "Roboto", sans-serif;
  font-size: 11pt;
  font-weight: 300;
  pointer-events: none;
}

.link {
  fill: none;
  stroke: gray;
  stroke-width: 1.5px;
}
</style>

<script type="text/javascript">

// The alignment-baseline property is SVG standard, but Firefox does not support
// it yet. Thus this will work worse in Firefox.

function SVG(element_name) {
  return document.createElementNS("http://www.w3.org/2000/svg", element_name);
}

// Global parameters.
var OntoVis = {};
OntoVis.width = 960;
OntoVis.height = 800;
OntoVis.marginX = 80;
OntoVis.marginY = 20;
OntoVis.nodePaddingX = 5;
OntoVis.nodePaddingY = 3;
OntoVis.duration = 500;
OntoVis.maxLevelDistance = 250;

// Global utils.
// projection() specifies a transform of coordinates for generated links.
OntoVis._diagonal = d3.svg.diagonal().projection(
  function(d) {
    return [d.y, d.x];
  });
OntoVis._colors = d3.scale.category20();

// For a <text> element in <svg>, generate its bounding box, colored according
// to its level.
function createTextBox(text_element, paddings) {
  var bbox = text_element.getBBox();

  var depth = d3.select(text_element).datum().depth;
  // We use this formula because in the default D3 20-color palette, color
  // 0, 2, ..., 18 are dark colors, and color 1, 3, ..., 19 are light colors.
  var color = depth % 10 * 2 + 1;

  var box = SVG("rect");
  $(text_element).parent().prepend(box);
  $(box).attr("id", "box_" + text_element.id);
  $(box).attr("fill", OntoVis._colors(color));
  $(box).attr("rx", "5");
  $(box).attr("ry", "5");
  $(box).attr("x", bbox.x - paddings.x);
  $(box).attr("y", bbox.y - paddings.y);
  $(box).attr("width", bbox.width + paddings.x * 2);
  $(box).attr("height", bbox.height + paddings.y * 2);
}

// Create bounding boxes with giving paddings for SVG text elements.
// paddings: { x: <horizontal padding>, y: <vertical padding> }
function createTextBoxes(paddings) {
  var text_elements = $("#elements text");
  for (var i = 0; i < text_elements.length; ++i) {
    createTextBox(text_elements[i], paddings);
  }
}

// Create and initialize the layout.
function createLayout() {
  // Initialize color palette.
  for (var c = 0; c < 20; ++c) {
    console.log("color " + c + ": " + OntoVis._colors(c));
  }

  // Initialize the SVG canvas.
  var svg = SVG("svg");
  $("div#viz").append(svg);
  $(svg).attr("width", OntoVis.width);
  $(svg).attr("height", OntoVis.height);

  var g_links = SVG("g");
  $(g_links).attr("id", "links");
  $(g_links).attr("transform",
                  "translate(" + OntoVis.marginX + " " + OntoVis.marginY + ")");
  $(svg).append(g_links);
  var g_texts = SVG("g");
  $(g_texts).attr("id", "elements");
  $(svg).append(g_texts);

  // Initialize the tree layout.
  var visibleWidth = OntoVis.width - OntoVis.marginX * 2;
  var visibleHeight = OntoVis.height - OntoVis.marginY * 2;
  var layout = d3.layout.tree()
    .size([visibleWidth, visibleHeight])
    .children(function(d) { return d.subtypes; });
  OntoVis.layout = layout;

  // Load JSON data and initialize.
  d3.json("mmd_repo.json", function(error, root) {
      OntoVis.root = root;
      // See the later explanation of x0 and y0.
      root.x0 = 0;
      root.y0 = OntoVis.height / 2;

      function collapse(node) {
        if (node.subtypes) {
          node._subtypes = node.subtypes;
          node.subtypes.forEach(collapse);
          node.subtypes = null;
        }
      }
      // Collapse subtrees.
      root.subtypes.forEach(collapse);

      update(root);
  });
}

// Update the presentation when clicking events happen.
function update(source) {
  // Use D3 to generate the layout.
  // This will set the x-y coordinates for nodes.
  var nodes = OntoVis.layout.nodes(OntoVis.root);
  var links = OntoVis.layout.links(nodes);

  // Set the max distance between two levels of nodes, for readability.
  nodes.forEach(
    function(d) {
      if (d.y > d.depth * OntoVis.maxLevelDistance) {
        d.y = d.depth * OntoVis.maxLevelDistance;
      }
    });

  // Select nodes and bind data.
  var elements = d3.select("div#viz > svg > g#elements").selectAll("g");
  // The 2nd argument determines an ID, so that D3 can maintain correspondence
  // between data and generated visuals.
  var node = elements.data(nodes, function(d) { return d.name; });

  // For entering nodes, initially create them at the clicked node (which is
  // their parent node).
  //
  // Since the source may be relocated at the beginning of update(), we need to
  // use the saved previous location of the source node, which is specified in
  // source.x0 and source.y0.
  //
  // Translates are specified on the <g> element so that the bounding box can be
  // translated along with the text.
  var enteringNodes =
    node.enter()
      .insert("g")
      .attr("transform",
            function(d) {
              var x = source.y0 + OntoVis.marginX;
              var y = source.x0 + OntoVis.marginY;
              return "translate(" + x + " " + y + ")";
            });
  enteringNodes
    .insert("text")
    .attr("id", function(d) { return "text_" + d.name; })
    .attr("class", "text")
    .attr("text-anchor", "middle")
    .attr("alignment-baseline", "middle")
    .text(function(d) { return d.name; });
  createTextBoxes({ "x": OntoVis.nodePaddingX, "y": OntoVis.nodePaddingY });

  // Transit existing and entering nodes to their new locations (specified in
  // d.x and d.y).
  node
    .transition()
    .duration(OntoVis.duration)
    .attr("transform",
          function(d) {
            var x = d.y + OntoVis.marginX;
            var y = d.x + OntoVis.marginY;
            return "translate(" + x + " " + y + ")";
          });

  enteringNodes.on("click", click);

  // For exiting nodes, transit them to the clicked node (which is their
  // parent) before removing them.
  var exitingNodes =
    node.exit()
      .transition()
      .duration(OntoVis.duration)
      .attr("transform",
            function(d) {
              var x = source.y + OntoVis.marginX;
              var y = source.x + OntoVis.marginY;
              return "translate(" + x + " " + y + ")";
            })
      .remove();

  // Bind links data.
  var connectors = d3.select("div#viz > svg > g#links").selectAll("path");
  // Again, the 2nd argument determines an ID for maintaining correspondence.
  var link = connectors.data(links, function(d) { return d.target.name; });

  // For entering links, initially show them as essentially 1 point near the
  // saved location of the clicked node.
  link.enter()
    .insert("path")
      .attr("class", "link")
      .attr("d",
            function(d) {
              var o = { x: source.x0, y: source.y0 };
              return OntoVis._diagonal({ source: o, target: o });
            });

  // Transit existing and entering links to their full shapes and new locations.
  link
    .transition()
    .duration(OntoVis.duration)
    .attr("d", OntoVis._diagonal);

  // For exiting links, transit them into 1 point near the clicked node before
  // removing.
  link.exit()
    .transition()
    .duration(OntoVis.duration)
    .attr("d",
          function(d) {
            var o = { x: source.x, y: source.y };
            return OntoVis._diagonal({ source: o, target: o });
          })
    .remove();

  // Save the location of each node before next update().
  nodes.forEach(function(d) { d.x0 = d.x; d.y0 = d.y; });
}

function click(d) {
  if (d.subtypes) {
    // Collapse
    d._subtypes = d.subtypes;
    d.subtypes = null;
  } else {
    // Expand
    d.subtypes = d._subtypes;
    d._subtypes = null;
  }
  update(d);
}

$(document).ready(createLayout);
</script>

<body>

<div id="viz">
</div>

</body>
